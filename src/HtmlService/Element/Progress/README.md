## Use with CardService app

### Simple implementation

A basic implementation requires four things:

1. An action that opens the progess bar popup window, which includes the name of the callback function (#2)
2. A callback function that actually performs the action that will be tracked by the progress bar
3. A web request handler to serve up the progress bar when a web request is made of the app
4. Exposing the `include()` and `getProgresss()` API function that responds to the progress bar's asynchronous requests for, well, progress.

```ts
import g from '@battis/gas-lighter';

// #1: CardService app that includes an OpenLink action to show the progress bar
global.onHomepage = () => {
  return g.CardService.Card.create({
    sections: [
      g.CardService.Card.newCardSection({
        widgets: [
          CardService.newTextButton()
            .setText('Start a job')
            .setOpenLink(
              CardService.newOpenLink()
                .setUrl(
                  // URL of script is stored as script property `URL`
                  `${g.PropertiesService.getScriptProperty('URL')}?job=${
                    // job ID generated by the Progress element
                    new g.HtmlService.Element.Progress.Tracker().job
                    // pass the name of the function that will perform the tracked job
                  }&callback=trackedProgress`
                )
                .setOpenAs(CardService.OpenAs.OVERLAY)
                .setOnClose(CardService.OnClose.RELOAD_ADD_ON)
            )
        ]
      })
    ]
  });
};

// mock data source
const data = [...new Array(1000).keys()].map((i) => i + 1);

// #2: callback function that runs the actual tracked process
global.trackedProgress = (job: string) => {
  const tracker = new g.HtmlService.Element.Progress.Tracker({ job });
  tracker.reset();
  for (const d of data) {
    tracker.status = `Step #${d}`;
    tracker.value++;
  }
  tracker.complete = true;
};

// #3: web request handler (_must_ be named `doGet`) that provides the actual progress bar
global.doGet = ({ parameter: data }: GoogleAppsScript.Events.DoGet) => {
  return new g.HtmlService.Element.Progress.View({
    job: data.job
  }).show.Popup({ data });
};

// #4: expose the provided progress bar status handler
global.include = g.HtmlService.Template.include;
global.getProgress = g.HtmlService.Element.Progress.getProgress;
```

### Handling long-running scripts

[There is a timeout, whose length depends on the type of account hosting the app.](https://developers.google.com/apps-script/guides/services/quotas) In a standard Google account, a script can run for 6 minutes, in a Google Workspace, the script can run for 30 minutes. Regardless, it is desirable to be able to run scripts that take longer than that. To do this, the data needs to be broken into pages, with each page processed separately. With this setup, the progress bar can detect when it is getting close to timing out, note its current page, and relaunch the callback at the next page, to continue the script until completion.

To do this, the callback function needs to define the Tracker more precisely, so that the duration of each page of processing can be tracked:

```ts
// mock data source
const data = new Array(1000).map((,i) => { data[i] = i + 1; });

// #2: callback function that runs the actual tracked process
global.trackedProgress = (job: string, page?: number) => {
  return new g.HtmlService.Element.Progress.Tracker({
    job,
    paging: {
      page,
      loader: ({ page, tracker }) => {
        tracker.max = data.length;
        tracker.value = page;
        return data.slice(page);
      },
      handler: ({ data, tracker }) => {
        tracker.value++;
        tracker.status = `Step #${data}`;
      },
      callback: 'trackedProgress'
    }
  }).run(); // run the Tracker's process wrapper after definition
};
```

### Caution

At present, the Progess element does not detect account types, and assumes a 30-minute script timeout in general.

### Parallel Processing

Using this same model, it is theoretically possible to break apart a dataset and process it in parallel using a map-reduce approach. While that is not yet implemented, a known limitation is the number of [simultaneous script executions](https://developers.google.com/apps-script/guides/services/quotas) (30 per user).

## Use in a Google Workspace Add-on

### Simple implementation

A basic implementation requires two things:

1. An action that opens creates a progress tracker and updates it
2. Exposing the `include()` and `getProgresss()` API function that responds to the progress bar's asynchronous requests for, well, progress.

```ts
import g from '@battis/gas-lighter';

global.onOpen = () => {
  SpreadsheetApp.getUi()
    .createAddonMenu()
    .addItem('Start a job', 'trackedProgress')
    .addToUi();
};

// mocked data
const data = [...new Array(1000).keys()].map((i) => i + 1);

// #1: create a progress tracker and show it as a modal dialog
global.trackedProgress = () => {
  const tracker = new g.HtmlService.Element.Progress.Tracker();
  tracker.view.show.Modal({
    title: 'The Count',
    root: SpreadsheetApp,
    height: 100
  });
  tracker.max = data.length;

  // perform the the task, updating the tracker
  for (const d of data) {
    tracker.status = `Step #${d}`;
    tracker.value++;
  }
  tracker.complete = true;
};

// #2: expose the API functions
global.include = g.HtmlService.Template.include;
global.getProgress = g.HtmlService.Element.Progress.getProgress;
```

### Handling long-running scripts

As noted above for CardService apps, quotas on script runtimes can be inconvenient, but breaking a task into pages that can be performed individually allows for the progress tracker to asynchronously resume the job when the script times out.

```ts
// mocked data
const data = [...new Array(1000).keys()].map((i) => i + 1);

// #1: create a progress tracker and show it as a modal dialog
global.trackedProgress =  => {
  // generate a job ID
  const tracker = new g.HtmlService.Element.Progress.Tracker();

  // show the modal dialog containing the progress view
  tracker.view.show.Modal({
    title: 'The Count',
    root: SpreadsheetApp,
    height: 100
  });

  // start the paged tracker run
  trackerCallback(tracker.job)
};

global.trackerCallback = (job: string, page?: number) = > {
  // instantiate the paged tracker
  const tracker = new g.HtmlService.Element.Progress.Tracker({
    job,
    paging: {
      page,
      loader: ({ page, tracker }) => {
        tracker.max = data.length;
        tracker.value = page;
        return data.slice(page);
      },
      handler: ({ data, tracker }) => {
        tracker.value++;
        tracker.status = `Step #${data}`;
      },
      callback: 'trackerCallback'
    }
  }).run();
}
```
