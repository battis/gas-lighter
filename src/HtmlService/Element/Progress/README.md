## Use with CardService app

### Simple implementation

A basic implementation requires four things:

1. An action that opens the progess bar popup window, which includes the name of the callback function (#2)
2. A callback function that actually performs the action that will be tracked by the progress bar
3. A web request handler to serve up the progress bar when a web request is made of the app
4. Exposing the `getProgresss()` API function that responds to the progress bar's asynchronous requests for, well, progress.

```ts
import g from '@battis/gas-lighter';

// #1: CardService app that includes an OpenLink action to show the progress bar
global.onHomepage = () => {
  return g.CardService.Card.create({
    sections: [
      g.CardService.Card.newCardSection({
        widgets: [
          CardService.newTextButton()
            .setText('Start a Job')
            .setOpenLink(
              CardService.newOpenLink()
                .setUrl(
                  // URL of script is stored as script property `URL`
                  `${g.PropertiesService.getScriptProperty('URL')}?job=${
                    // job ID generated by the Progress element
                    new g.HtmlService.Element.Progress.Tracker().job
                    // pass the name of the function that will perform the tracked job
                  }&callback=trackedProgress`
                )
                .setOpenAs(CardService.OpenAs.OVERLAY)
                .setOnClose(CardService.OnClose.RELOAD_ADD_ON)
            )
        ]
      })
    ]
  });
};

// mock data source
const data = new Array(1000).map((,i) => { data[i] = i + 1; });

// #2: callback function that runs the actual tracked process
global.trackedProgress = (job: string) => {
  const tracker = new g.HtmlService.Element.Progress.Tracker({ job });
  tracker.reset();
  for (const d of data) {
    tracker.status = `Step #${d}`;
    tracker.value++;
  }
  tracker.complete = true;
};

// #3: web request handler (_must_ be named `doGet`) that provides the actual progress bar
global.doGet = ({ parameter: data }: GoogleAppsScript.Events.DoGet) => {
  return new g.HtmlService.Element.Progress.View({
    job: data.job
  }).show.Popup({ data });
};

// #4: expose the provided progress bar status handler
global.getProgress = g.HtmlService.Element.Progress.getProgress;
```

### Handling long-running scripts

[There is a timeout, whose length depends on the type of account hosting the app.](https://developers.google.com/apps-script/guides/services/quotas) In a standard Google account, a script can run for 6 minutes, in a Google Workspace, the script can run for 30 minutes. Regardless, it is desirable to be able to run scripts that take longer than that. To do this, the data needs to be broken into pages, with each page processed separately. With this setup, the progress bar can detect when it is getting close to timing out, note its current page, and relaunch the callback at the next page, to continue the script until completion.

To do this, the callback function needs to define the Tracker more precisely, so that the duration of each page of processing can be tracked:

```ts
// mock data source
const data = new Array(1000).map((,i) => { data[i] = i + 1; });

// #2: callback function that runs the actual tracked process
global.trackedProgress = (job: string, page?: number) => {
  return new g.HtmlService.Element.Progress.Tracker({
    job,
    paging: {
      page,
      loader: ({ page, tracker }) => {
        tracker.max = data.length;
        tracker.value = page;
        return data.slice(page);
      },
      handler: ({ data, tracker }) => {
        tracker.value++;
        tracker.status = `Step #${data}`;
      },
      callback
    }
  }).run(); // run the Tracker's process wrapper after definition
};
```

### Caution

At present, the Progess element does not detect account types, and assumes a 30-minute script timeout in general.

### Parallel Processing

Using this same model, it is theoretically possible to break apart a dataset and process it in parallel using a map-reduce approach. While that is not yet implemented, a known limitation is the number of [simultaneous script executions](https://developers.google.com/apps-script/guides/services/quotas) (30 per user).
